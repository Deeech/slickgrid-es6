{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///slick.plugins.es6.min.js","webpack:///webpack/bootstrap 151b9d735cb97ac443f9","webpack:///./src/slick.core.js","webpack:///./plugins/index.js","webpack:///./plugins/slick.cellselectionmodel.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","callbacks","length","installedChunks","push","apply","shift","0","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","global","EventData","isPropagationStopped","isImmediatePropagationStopped","stopPropagation","stopImmediatePropagation","Event","handlers","subscribe","fn","unsubscribe","splice","notify","args","scope","returnValue","EventHandler","event","handler","unsubscribeAll","Range","fromRow","fromCell","toRow","toCell","Math","min","max","isSingleRow","isSingleCell","contains","row","cell","toString","NonDataItem","__nonDataRow","Group","__group","level","count","value","title","collapsed","totals","rows","groups","groupingKey","GroupTotals","__groupTotals","group","initialized","EditorLock","activeEditController","isActive","editController","activate","commitCurrentEdit","cancelCurrentEdit","deactivate","Object","defineProperty","Slick","NonDataRow","GlobalEditorLock","keyCode","BACKSPACE","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","TAB","UP","default","prototype","equals","_interopRequireDefault","obj","__esModule","CellSelectionModel","_slickCellselectionmodel","_slickCellselectionmodel2","init","grid","_options","assign","options","_grid","_canvas","getCanvasNode","onActiveCellChanged","handleActiveCellChange","onKeyDown","handleKeyDown","registerPlugin","_selector","onCellRangeSelected","handleCellRangeSelected","onBeforeCellRangeSelected","handleBeforeCellRangeSelected","destroy","unregisterPlugin","removeInvalidRanges","ranges","result","r","canCellBeSelected","setSelectedRanges","_ranges","_self","onSelectedRangesChanged","getSelectedRanges","getEditorLock","range","selectActiveCell","_slick2","last","active","getActiveCell","shiftKey","ctrlKey","altKey","which","pop","dRow","dCell","dirRow","dirCell","new_last","viewRow","viewCell","scrollRowIntoView","scrollCellIntoView","preventDefault","arguments","CellRangeSelector","selectionCss","border","extend","_slick"],"mappings":"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","file":"slick.plugins.es6.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".slick.es6.min.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(4);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/** *\n\t * Contains core SlickGrid classes.\n\t * @module Core\n\t * @namespace Slick\n\t */\n\tvar Slick = {\n\t  Event: Event,\n\t  EventData: EventData,\n\t  EventHandler: EventHandler,\n\t  Range: Range,\n\t  NonDataRow: NonDataItem,\n\t  Group: Group,\n\t  GroupTotals: GroupTotals,\n\t  EditorLock: EditorLock,\n\t\n\t  /** *\n\t   * A global singleton editor lock.\n\t   * @class GlobalEditorLock\n\t   * @static\n\t   * @constructor\n\t   */\n\t  GlobalEditorLock: new EditorLock(),\n\t\n\t  keyCode: {\n\t    BACKSPACE: 8,\n\t    DELETE: 46,\n\t    DOWN: 40,\n\t    END: 35,\n\t    ENTER: 13,\n\t    ESCAPE: 27,\n\t    HOME: 36,\n\t    INSERT: 45,\n\t    LEFT: 37,\n\t    PAGE_DOWN: 34,\n\t    PAGE_UP: 33,\n\t    RIGHT: 39,\n\t    TAB: 9,\n\t    UP: 38\n\t  }\n\t};\n\t\n\tglobal.Slick = Slick;\n\texports.default = Slick;\n\t\n\t/** *\n\t * An event object for passing data to event handlers and letting them control propagation.\n\t * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n\t * @class EventData\n\t * @constructor\n\t */\n\t\n\tfunction EventData() {\n\t  var isPropagationStopped = false;\n\t  var isImmediatePropagationStopped = false;\n\t\n\t  /** *\n\t   * Stops event from propagating up the DOM tree.\n\t   * @method stopPropagation\n\t   */\n\t  this.stopPropagation = function () {\n\t    isPropagationStopped = true;\n\t  };\n\t\n\t  /** *\n\t   * Returns whether stopPropagation was called on this event object.\n\t   * @method isPropagationStopped\n\t   * @return {Boolean}\n\t   */\n\t  this.isPropagationStopped = function () {\n\t    return isPropagationStopped;\n\t  };\n\t\n\t  /** *\n\t   * Prevents the rest of the handlers from being executed.\n\t   * @method stopImmediatePropagation\n\t   */\n\t  this.stopImmediatePropagation = function () {\n\t    isImmediatePropagationStopped = true;\n\t  };\n\t\n\t  /** *\n\t   * Returns whether stopImmediatePropagation was called on this event object.\\\n\t   * @method isImmediatePropagationStopped\n\t   * @return {Boolean}\n\t   */\n\t  this.isImmediatePropagationStopped = function () {\n\t    return isImmediatePropagationStopped;\n\t  };\n\t}\n\t\n\t/** *\n\t * A simple publisher-subscriber implementation.\n\t * @class Event\n\t * @constructor\n\t */\n\tfunction Event() {\n\t  var handlers = [];\n\t\n\t  /** *\n\t   * Adds an event handler to be called when the event is fired.\n\t   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n\t   * object the event was fired with.<p>\n\t   * @method subscribe\n\t   * @param fn {Function} Event handler.\n\t   */\n\t  this.subscribe = function (fn) {\n\t    handlers.push(fn);\n\t  };\n\t\n\t  /** *\n\t   * Removes an event handler added with <code>subscribe(fn)</code>.\n\t   * @method unsubscribe\n\t   * @param fn {Function} Event handler to be removed.\n\t   */\n\t  this.unsubscribe = function (fn) {\n\t    for (var i = handlers.length - 1; i >= 0; i--) {\n\t      if (handlers[i] === fn) {\n\t        handlers.splice(i, 1);\n\t      }\n\t    }\n\t  };\n\t\n\t  /** *\n\t   * Fires an event notifying all subscribers.\n\t   * @method notify\n\t   * @param args {Object} Additional data object to be passed to all handlers.\n\t   * @param e {EventData}\n\t   *      Optional.\n\t   *      An <code>EventData</code> object to be passed to all handlers.\n\t   *      For DOM events, an existing W3C/jQuery event object can be passed in.\n\t   * @param scope {Object}\n\t   *      Optional.\n\t   *      The scope (\"this\") within which the handler will be executed.\n\t   *      If not specified, the scope will be set to the <code>Event</code> instance.\n\t   */\n\t  this.notify = function (args, e, scope) {\n\t    e = e || new EventData();\n\t    scope = scope || this;\n\t\n\t    var returnValue;\n\t    for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n\t      returnValue = handlers[i].call(scope, e, args);\n\t    }\n\t\n\t    return returnValue;\n\t  };\n\t}\n\t\n\tfunction EventHandler() {\n\t  var handlers = [];\n\t\n\t  this.subscribe = function (event, handler) {\n\t    handlers.push({\n\t      event: event,\n\t      handler: handler\n\t    });\n\t    event.subscribe(handler);\n\t\n\t    return this; // allow chaining\n\t  };\n\t\n\t  this.unsubscribe = function (event, handler) {\n\t    var i = handlers.length;\n\t    while (i--) {\n\t      if (handlers[i].event === event && handlers[i].handler === handler) {\n\t        handlers.splice(i, 1);\n\t        event.unsubscribe(handler);\n\t        return;\n\t      }\n\t    }\n\t\n\t    return this; // allow chaining\n\t  };\n\t\n\t  this.unsubscribeAll = function () {\n\t    var i = handlers.length;\n\t    while (i--) {\n\t      handlers[i].event.unsubscribe(handlers[i].handler);\n\t    }\n\t    handlers = [];\n\t\n\t    return this; // allow chaining\n\t  };\n\t}\n\t\n\t/** *\n\t * A structure containing a range of cells.\n\t * @class Range\n\t * @constructor\n\t * @param fromRow {Integer} Starting row.\n\t * @param fromCell {Integer} Starting cell.\n\t * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n\t * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n\t */\n\tfunction Range(fromRow, fromCell, toRow, toCell) {\n\t  if (toRow === undefined && toCell === undefined) {\n\t    toRow = fromRow;\n\t    toCell = fromCell;\n\t  }\n\t\n\t  /** *\n\t   * @property fromRow\n\t   * @type {Integer}\n\t   */\n\t  this.fromRow = Math.min(fromRow, toRow);\n\t\n\t  /** *\n\t   * @property fromCell\n\t   * @type {Integer}\n\t   */\n\t  this.fromCell = Math.min(fromCell, toCell);\n\t\n\t  /** *\n\t   * @property toRow\n\t   * @type {Integer}\n\t   */\n\t  this.toRow = Math.max(fromRow, toRow);\n\t\n\t  /** *\n\t   * @property toCell\n\t   * @type {Integer}\n\t   */\n\t  this.toCell = Math.max(fromCell, toCell);\n\t\n\t  /** *\n\t   * Returns whether a range represents a single row.\n\t   * @method isSingleRow\n\t   * @return {Boolean}\n\t   */\n\t  this.isSingleRow = function () {\n\t    return this.fromRow == this.toRow;\n\t  };\n\t\n\t  /** *\n\t   * Returns whether a range represents a single cell.\n\t   * @method isSingleCell\n\t   * @return {Boolean}\n\t   */\n\t  this.isSingleCell = function () {\n\t    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n\t  };\n\t\n\t  /** *\n\t   * Returns whether a range contains a given cell.\n\t   * @method contains\n\t   * @param row {Integer}\n\t   * @param cell {Integer}\n\t   * @return {Boolean}\n\t   */\n\t  this.contains = function (row, cell) {\n\t    return row >= this.fromRow && row <= this.toRow && cell >= this.fromCell && cell <= this.toCell;\n\t  };\n\t\n\t  /** *\n\t   * Returns a readable representation of a range.\n\t   * @method toString\n\t   * @return {String}\n\t   */\n\t  this.toString = function () {\n\t    if (this.isSingleCell()) {\n\t      return '(' + this.fromRow + ':' + this.fromCell + ')';\n\t    } else {\n\t      return '(' + this.fromRow + ':' + this.fromCell + ' - ' + this.toRow + ':' + this.toCell + ')';\n\t    }\n\t  };\n\t}\n\t\n\t/** *\n\t * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n\t * @class NonDataItem\n\t * @constructor\n\t */\n\tfunction NonDataItem() {\n\t  this.__nonDataRow = true;\n\t}\n\t\n\t/** *\n\t * Information about a group of rows.\n\t * @class Group\n\t * @extends Slick.NonDataItem\n\t * @constructor\n\t */\n\tfunction Group() {\n\t  this.__group = true;\n\t\n\t  /**\n\t   * Grouping level, starting with 0.\n\t   * @property level\n\t   * @type {Number}\n\t   */\n\t  this.level = 0;\n\t\n\t  /** *\n\t   * Number of rows in the group.\n\t   * @property count\n\t   * @type {Integer}\n\t   */\n\t  this.count = 0;\n\t\n\t  /** *\n\t   * Grouping value.\n\t   * @property value\n\t   * @type {Object}\n\t   */\n\t  this.value = null;\n\t\n\t  /** *\n\t   * Formatted display value of the group.\n\t   * @property title\n\t   * @type {String}\n\t   */\n\t  this.title = null;\n\t\n\t  /** *\n\t   * Whether a group is collapsed.\n\t   * @property collapsed\n\t   * @type {Boolean}\n\t   */\n\t  this.collapsed = false;\n\t\n\t  /** *\n\t   * GroupTotals, if any.\n\t   * @property totals\n\t   * @type {GroupTotals}\n\t   */\n\t  this.totals = null;\n\t\n\t  /**\n\t   * Rows that are part of the group.\n\t   * @property rows\n\t   * @type {Array}\n\t   */\n\t  this.rows = [];\n\t\n\t  /**\n\t   * Sub-groups that are part of the group.\n\t   * @property groups\n\t   * @type {Array}\n\t   */\n\t  this.groups = null;\n\t\n\t  /**\n\t   * A unique key used to identify the group.  This key can be used in calls to DataView\n\t   * collapseGroup() or expandGroup().\n\t   * @property groupingKey\n\t   * @type {Object}\n\t   */\n\t  this.groupingKey = null;\n\t}\n\t\n\tGroup.prototype = new NonDataItem();\n\t\n\t/** *\n\t * Compares two Group instances.\n\t * @method equals\n\t * @return {Boolean}\n\t * @param group {Group} Group instance to compare to.\n\t */\n\tGroup.prototype.equals = function (group) {\n\t  return this.value === group.value && this.count === group.count && this.collapsed === group.collapsed && this.title === group.title;\n\t};\n\t\n\t/** *\n\t * Information about group totals.\n\t * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n\t * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n\t * formatters during the display.\n\t * @class GroupTotals\n\t * @extends Slick.NonDataItem\n\t * @constructor\n\t */\n\tfunction GroupTotals() {\n\t  this.__groupTotals = true;\n\t\n\t  /** *\n\t   * Parent Group.\n\t   * @param group\n\t   * @type {Group}\n\t   */\n\t  this.group = null;\n\t\n\t  /** *\n\t   * Whether the totals have been fully initialized / calculated.\n\t   * Will be set to false for lazy-calculated group totals.\n\t   * @param initialized\n\t   * @type {Boolean}\n\t   */\n\t  this.initialized = false;\n\t}\n\t\n\tGroupTotals.prototype = new NonDataItem();\n\t\n\t/** *\n\t * A locking helper to track the active edit controller and ensure that only a single controller\n\t * can be active at a time.  This prevents a whole class of state and validation synchronization\n\t * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n\t * and attempt a commit or cancel before proceeding.\n\t * @class EditorLock\n\t * @constructor\n\t */\n\tfunction EditorLock() {\n\t  var activeEditController = null;\n\t\n\t  /** *\n\t   * Returns true if a specified edit controller is active (has the edit lock).\n\t   * If the parameter is not specified, returns true if any edit controller is active.\n\t   * @method isActive\n\t   * @param editController {EditController}\n\t   * @return {Boolean}\n\t   */\n\t  this.isActive = function (editController) {\n\t    return editController ? activeEditController === editController : activeEditController !== null;\n\t  };\n\t\n\t  /** *\n\t   * Sets the specified edit controller as the active edit controller (acquire edit lock).\n\t   * If another edit controller is already active, and exception will be thrown.\n\t   * @method activate\n\t   * @param editController {EditController} edit controller acquiring the lock\n\t   */\n\t  this.activate = function (editController) {\n\t    if (editController === activeEditController) {\n\t      // already activated?\n\t      return;\n\t    }\n\t    if (activeEditController !== null) {\n\t      throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n\t    }\n\t    if (!editController.commitCurrentEdit) {\n\t      throw 'SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()';\n\t    }\n\t    if (!editController.cancelCurrentEdit) {\n\t      throw 'SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()';\n\t    }\n\t    activeEditController = editController;\n\t  };\n\t\n\t  /** *\n\t   * Unsets the specified edit controller as the active edit controller (release edit lock).\n\t   * If the specified edit controller is not the active one, an exception will be thrown.\n\t   * @method deactivate\n\t   * @param editController {EditController} edit controller releasing the lock\n\t   */\n\t  this.deactivate = function (editController) {\n\t    if (activeEditController !== editController) {\n\t      throw 'SlickGrid.EditorLock.deactivate: specified editController is not the currently active one';\n\t    }\n\t    activeEditController = null;\n\t  };\n\t\n\t  /** *\n\t   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n\t   * controller and returns whether the commit attempt was successful (commit may fail due to validation\n\t   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n\t   * and false otherwise.  If no edit controller is active, returns true.\n\t   * @method commitCurrentEdit\n\t   * @return {Boolean}\n\t   */\n\t  this.commitCurrentEdit = function () {\n\t    return activeEditController ? activeEditController.commitCurrentEdit() : true;\n\t  };\n\t\n\t  /** *\n\t   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n\t   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n\t   * active, returns true.\n\t   * @method cancelCurrentEdit\n\t   * @return {Boolean}\n\t   */\n\t  this.cancelCurrentEdit = function cancelCurrentEdit() {\n\t    return activeEditController ? activeEditController.cancelCurrentEdit() : true;\n\t  };\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.CellSelectionModel = undefined;\n\t\n\tvar _slickCellselectionmodel = __webpack_require__(5);\n\t\n\tvar _slickCellselectionmodel2 = _interopRequireDefault(_slickCellselectionmodel);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.CellSelectionModel = _slickCellselectionmodel2.default; // todo: convert and export the other plugins here\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slick = __webpack_require__(1);\n\t\n\tvar _slick2 = _interopRequireDefault(_slick);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_slick2.default.CellSelectionModel = CellSelectionModel;\n\texports.default = CellSelectionModel;\n\t\n\t\n\tfunction CellSelectionModel() {\n\t  var options = arguments.length <= 0 || arguments[0] === undefined ? {\n\t    selectActiveCell: true\n\t  } : arguments[0];\n\t\n\t  var _grid;\n\t  var _canvas;\n\t  var _ranges = [];\n\t  var _self = this;\n\t  var _selector = new _slick2.default.CellRangeSelector({\n\t    selectionCss: {\n\t      border: \"2px solid black\"\n\t    }\n\t  });\n\t  var _options;\n\t  var _defaults = {\n\t    selectActiveCell: true\n\t  };\n\t\n\t  function init(grid) {\n\t    _options = Object.assign({}, options);\n\t    _grid = grid;\n\t    _canvas = _grid.getCanvasNode();\n\t    _grid.onActiveCellChanged.subscribe(handleActiveCellChange);\n\t    _grid.onKeyDown.subscribe(handleKeyDown);\n\t    grid.registerPlugin(_selector);\n\t    _selector.onCellRangeSelected.subscribe(handleCellRangeSelected);\n\t    _selector.onBeforeCellRangeSelected.subscribe(handleBeforeCellRangeSelected);\n\t  }\n\t\n\t  function destroy() {\n\t    _grid.onActiveCellChanged.unsubscribe(handleActiveCellChange);\n\t    _grid.onKeyDown.unsubscribe(handleKeyDown);\n\t    _selector.onCellRangeSelected.unsubscribe(handleCellRangeSelected);\n\t    _selector.onBeforeCellRangeSelected.unsubscribe(handleBeforeCellRangeSelected);\n\t    _grid.unregisterPlugin(_selector);\n\t  }\n\t\n\t  function removeInvalidRanges(ranges) {\n\t    var result = [];\n\t\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var r = ranges[i];\n\t      if (_grid.canCellBeSelected(r.fromRow, r.fromCell) && _grid.canCellBeSelected(r.toRow, r.toCell)) {\n\t        result.push(r);\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  function setSelectedRanges(ranges) {\n\t    // simle check for: empty selection didn't change, prevent firing onSelectedRangesChanged\n\t    if ((!_ranges || _ranges.length === 0) && (!ranges || ranges.length === 0)) {\n\t      return;\n\t    }\n\t\n\t    _ranges = removeInvalidRanges(ranges);\n\t    _self.onSelectedRangesChanged.notify(_ranges);\n\t  }\n\t\n\t  function getSelectedRanges() {\n\t    return _ranges;\n\t  }\n\t\n\t  function handleBeforeCellRangeSelected(e, args) {\n\t    if (_grid.getEditorLock().isActive()) {\n\t      e.stopPropagation();\n\t      return false;\n\t    }\n\t  }\n\t\n\t  function handleCellRangeSelected(e, args) {\n\t    setSelectedRanges([args.range]);\n\t  }\n\t\n\t  function handleActiveCellChange(e, args) {\n\t    if (_options.selectActiveCell && args.row != null && args.cell != null) {\n\t      setSelectedRanges([new _slick2.default.Range(args.row, args.cell)]);\n\t    }\n\t  }\n\t\n\t  function handleKeyDown(e) {\n\t    /***\n\t     * Кey codes\n\t     * 37 left\n\t     * 38 up\n\t     * 39 right\n\t     * 40 down\n\t     */\n\t    var ranges, last;\n\t    var active = _grid.getActiveCell();\n\t\n\t    if (active && e.shiftKey && !e.ctrlKey && !e.altKey && (e.which == 37 || e.which == 39 || e.which == 38 || e.which == 40)) {\n\t\n\t      ranges = getSelectedRanges();\n\t      if (!ranges.length) ranges.push(new _slick2.default.Range(active.row, active.cell));\n\t\n\t      // keyboard can work with last range only\n\t      last = ranges.pop();\n\t\n\t      // can't handle selection out of active cell\n\t      if (!last.contains(active.row, active.cell)) last = new _slick2.default.Range(active.row, active.cell);\n\t\n\t      var dRow = last.toRow - last.fromRow,\n\t          dCell = last.toCell - last.fromCell,\n\t\n\t      // walking direction\n\t      dirRow = active.row == last.fromRow ? 1 : -1,\n\t          dirCell = active.cell == last.fromCell ? 1 : -1;\n\t\n\t      if (e.which == 37) {\n\t        dCell -= dirCell;\n\t      } else if (e.which == 39) {\n\t        dCell += dirCell;\n\t      } else if (e.which == 38) {\n\t        dRow -= dirRow;\n\t      } else if (e.which == 40) {\n\t        dRow += dirRow;\n\t      }\n\t\n\t      // define new selection range\n\t      var new_last = new _slick2.default.Range(active.row, active.cell, active.row + dirRow * dRow, active.cell + dirCell * dCell);\n\t      if (removeInvalidRanges([new_last]).length) {\n\t        ranges.push(new_last);\n\t        var viewRow = dirRow > 0 ? new_last.toRow : new_last.fromRow;\n\t        var viewCell = dirCell > 0 ? new_last.toCell : new_last.fromCell;\n\t        _grid.scrollRowIntoView(viewRow);\n\t        _grid.scrollCellIntoView(viewRow, viewCell);\n\t      } else ranges.push(last);\n\t\n\t      setSelectedRanges(ranges);\n\t\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\t    }\n\t  }\n\t\n\t  Object.extend(this, {\n\t    \"getSelectedRanges\": getSelectedRanges,\n\t    \"setSelectedRanges\": setSelectedRanges,\n\t\n\t    \"init\": init,\n\t    \"destroy\": destroy,\n\t\n\t    \"onSelectedRangesChanged\": new _slick2.default.Event()\n\t  });\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** slick.plugins.es6.min.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".slick.es6.min.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 151b9d735cb97ac443f9\n **/","/** *\n * Contains core SlickGrid classes.\n * @module Core\n * @namespace Slick\n */\nconst Slick = {\n  Event: Event,\n  EventData: EventData,\n  EventHandler: EventHandler,\n  Range: Range,\n  NonDataRow: NonDataItem,\n  Group: Group,\n  GroupTotals: GroupTotals,\n  EditorLock: EditorLock,\n\n  /** *\n   * A global singleton editor lock.\n   * @class GlobalEditorLock\n   * @static\n   * @constructor\n   */\n  GlobalEditorLock: new EditorLock(),\n\n  keyCode: {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    INSERT: 45,\n    LEFT: 37,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    RIGHT: 39,\n    TAB: 9,\n    UP: 38\n  }\n};\n\nglobal.Slick = Slick;\nexport default Slick;\n\n/** *\n * An event object for passing data to event handlers and letting them control propagation.\n * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n * @class EventData\n * @constructor\n */\nfunction EventData(){\n  var isPropagationStopped = false;\n  var isImmediatePropagationStopped = false;\n\n  /** *\n   * Stops event from propagating up the DOM tree.\n   * @method stopPropagation\n   */\n  this.stopPropagation = function(){\n    isPropagationStopped = true;\n  };\n\n  /** *\n   * Returns whether stopPropagation was called on this event object.\n   * @method isPropagationStopped\n   * @return {Boolean}\n   */\n  this.isPropagationStopped = function(){\n    return isPropagationStopped;\n  };\n\n  /** *\n   * Prevents the rest of the handlers from being executed.\n   * @method stopImmediatePropagation\n   */\n  this.stopImmediatePropagation = function(){\n    isImmediatePropagationStopped = true;\n  };\n\n  /** *\n   * Returns whether stopImmediatePropagation was called on this event object.\\\n   * @method isImmediatePropagationStopped\n   * @return {Boolean}\n   */\n  this.isImmediatePropagationStopped = function(){\n    return isImmediatePropagationStopped;\n  };\n}\n\n/** *\n * A simple publisher-subscriber implementation.\n * @class Event\n * @constructor\n */\nfunction Event(){\n  var handlers = [];\n\n  /** *\n   * Adds an event handler to be called when the event is fired.\n   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n   * object the event was fired with.<p>\n   * @method subscribe\n   * @param fn {Function} Event handler.\n   */\n  this.subscribe = function(fn){\n    handlers.push(fn);\n  };\n\n  /** *\n   * Removes an event handler added with <code>subscribe(fn)</code>.\n   * @method unsubscribe\n   * @param fn {Function} Event handler to be removed.\n   */\n  this.unsubscribe = function(fn){\n    for (var i = handlers.length - 1; i >= 0; i--){\n      if (handlers[i] === fn){\n        handlers.splice(i, 1);\n      }\n    }\n  };\n\n  /** *\n   * Fires an event notifying all subscribers.\n   * @method notify\n   * @param args {Object} Additional data object to be passed to all handlers.\n   * @param e {EventData}\n   *      Optional.\n   *      An <code>EventData</code> object to be passed to all handlers.\n   *      For DOM events, an existing W3C/jQuery event object can be passed in.\n   * @param scope {Object}\n   *      Optional.\n   *      The scope (\"this\") within which the handler will be executed.\n   *      If not specified, the scope will be set to the <code>Event</code> instance.\n   */\n  this.notify = function(args, e, scope){\n    e = e || new EventData();\n    scope = scope || this;\n\n    var returnValue;\n    for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++){\n      returnValue = handlers[i].call(scope, e, args);\n    }\n\n    return returnValue;\n  };\n}\n\nfunction EventHandler(){\n  var handlers = [];\n\n  this.subscribe = function(event, handler){\n    handlers.push({\n      event: event,\n      handler: handler\n    });\n    event.subscribe(handler);\n\n    return this;  // allow chaining\n  };\n\n  this.unsubscribe = function(event, handler){\n    var i = handlers.length;\n    while (i--){\n      if (handlers[i].event === event &&\n        handlers[i].handler === handler){\n        handlers.splice(i, 1);\n        event.unsubscribe(handler);\n        return;\n      }\n    }\n\n    return this;  // allow chaining\n  };\n\n  this.unsubscribeAll = function(){\n    var i = handlers.length;\n    while (i--){\n      handlers[i].event.unsubscribe(handlers[i].handler);\n    }\n    handlers = [];\n\n    return this;  // allow chaining\n  };\n}\n\n/** *\n * A structure containing a range of cells.\n * @class Range\n * @constructor\n * @param fromRow {Integer} Starting row.\n * @param fromCell {Integer} Starting cell.\n * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n */\nfunction Range(fromRow, fromCell, toRow, toCell){\n  if (toRow === undefined && toCell === undefined){\n    toRow = fromRow;\n    toCell = fromCell;\n  }\n\n  /** *\n   * @property fromRow\n   * @type {Integer}\n   */\n  this.fromRow = Math.min(fromRow, toRow);\n\n  /** *\n   * @property fromCell\n   * @type {Integer}\n   */\n  this.fromCell = Math.min(fromCell, toCell);\n\n  /** *\n   * @property toRow\n   * @type {Integer}\n   */\n  this.toRow = Math.max(fromRow, toRow);\n\n  /** *\n   * @property toCell\n   * @type {Integer}\n   */\n  this.toCell = Math.max(fromCell, toCell);\n\n  /** *\n   * Returns whether a range represents a single row.\n   * @method isSingleRow\n   * @return {Boolean}\n   */\n  this.isSingleRow = function(){\n    return this.fromRow == this.toRow;\n  };\n\n  /** *\n   * Returns whether a range represents a single cell.\n   * @method isSingleCell\n   * @return {Boolean}\n   */\n  this.isSingleCell = function(){\n    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n  };\n\n  /** *\n   * Returns whether a range contains a given cell.\n   * @method contains\n   * @param row {Integer}\n   * @param cell {Integer}\n   * @return {Boolean}\n   */\n  this.contains = function(row, cell){\n    return row >= this.fromRow && row <= this.toRow &&\n      cell >= this.fromCell && cell <= this.toCell;\n  };\n\n  /** *\n   * Returns a readable representation of a range.\n   * @method toString\n   * @return {String}\n   */\n  this.toString = function(){\n    if (this.isSingleCell()){\n      return '(' + this.fromRow + ':' + this.fromCell + ')';\n    }\n    else {\n      return '(' + this.fromRow + ':' + this.fromCell + ' - ' + this.toRow + ':' + this.toCell + ')';\n    }\n  };\n}\n\n/** *\n * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n * @class NonDataItem\n * @constructor\n */\nfunction NonDataItem(){\n  this.__nonDataRow = true;\n}\n\n/** *\n * Information about a group of rows.\n * @class Group\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction Group(){\n  this.__group = true;\n\n  /**\n   * Grouping level, starting with 0.\n   * @property level\n   * @type {Number}\n   */\n  this.level = 0;\n\n  /** *\n   * Number of rows in the group.\n   * @property count\n   * @type {Integer}\n   */\n  this.count = 0;\n\n  /** *\n   * Grouping value.\n   * @property value\n   * @type {Object}\n   */\n  this.value = null;\n\n  /** *\n   * Formatted display value of the group.\n   * @property title\n   * @type {String}\n   */\n  this.title = null;\n\n  /** *\n   * Whether a group is collapsed.\n   * @property collapsed\n   * @type {Boolean}\n   */\n  this.collapsed = false;\n\n  /** *\n   * GroupTotals, if any.\n   * @property totals\n   * @type {GroupTotals}\n   */\n  this.totals = null;\n\n  /**\n   * Rows that are part of the group.\n   * @property rows\n   * @type {Array}\n   */\n  this.rows = [];\n\n  /**\n   * Sub-groups that are part of the group.\n   * @property groups\n   * @type {Array}\n   */\n  this.groups = null;\n\n  /**\n   * A unique key used to identify the group.  This key can be used in calls to DataView\n   * collapseGroup() or expandGroup().\n   * @property groupingKey\n   * @type {Object}\n   */\n  this.groupingKey = null;\n}\n\nGroup.prototype = new NonDataItem();\n\n/** *\n * Compares two Group instances.\n * @method equals\n * @return {Boolean}\n * @param group {Group} Group instance to compare to.\n */\nGroup.prototype.equals = function(group){\n  return this.value === group.value &&\n    this.count === group.count &&\n    this.collapsed === group.collapsed &&\n    this.title === group.title;\n};\n\n/** *\n * Information about group totals.\n * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n * formatters during the display.\n * @class GroupTotals\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction GroupTotals(){\n  this.__groupTotals = true;\n\n  /** *\n   * Parent Group.\n   * @param group\n   * @type {Group}\n   */\n  this.group = null;\n\n  /** *\n   * Whether the totals have been fully initialized / calculated.\n   * Will be set to false for lazy-calculated group totals.\n   * @param initialized\n   * @type {Boolean}\n   */\n  this.initialized = false;\n}\n\nGroupTotals.prototype = new NonDataItem();\n\n/** *\n * A locking helper to track the active edit controller and ensure that only a single controller\n * can be active at a time.  This prevents a whole class of state and validation synchronization\n * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n * and attempt a commit or cancel before proceeding.\n * @class EditorLock\n * @constructor\n */\nfunction EditorLock(){\n  var activeEditController = null;\n\n  /** *\n   * Returns true if a specified edit controller is active (has the edit lock).\n   * If the parameter is not specified, returns true if any edit controller is active.\n   * @method isActive\n   * @param editController {EditController}\n   * @return {Boolean}\n   */\n  this.isActive = function(editController){\n    return (editController ? activeEditController === editController : activeEditController !== null);\n  };\n\n  /** *\n   * Sets the specified edit controller as the active edit controller (acquire edit lock).\n   * If another edit controller is already active, and exception will be thrown.\n   * @method activate\n   * @param editController {EditController} edit controller acquiring the lock\n   */\n  this.activate = function(editController){\n    if (editController === activeEditController){ // already activated?\n      return;\n    }\n    if (activeEditController !== null){\n      throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n    }\n    if (!editController.commitCurrentEdit){\n      throw 'SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()';\n    }\n    if (!editController.cancelCurrentEdit){\n      throw 'SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()';\n    }\n    activeEditController = editController;\n  };\n\n  /** *\n   * Unsets the specified edit controller as the active edit controller (release edit lock).\n   * If the specified edit controller is not the active one, an exception will be thrown.\n   * @method deactivate\n   * @param editController {EditController} edit controller releasing the lock\n   */\n  this.deactivate = function(editController){\n    if (activeEditController !== editController){\n      throw 'SlickGrid.EditorLock.deactivate: specified editController is not the currently active one';\n    }\n    activeEditController = null;\n  };\n\n  /** *\n   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n   * controller and returns whether the commit attempt was successful (commit may fail due to validation\n   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n   * and false otherwise.  If no edit controller is active, returns true.\n   * @method commitCurrentEdit\n   * @return {Boolean}\n   */\n  this.commitCurrentEdit = function(){\n    return (activeEditController ? activeEditController.commitCurrentEdit() : true);\n  };\n\n  /** *\n   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n   * active, returns true.\n   * @method cancelCurrentEdit\n   * @return {Boolean}\n   */\n  this.cancelCurrentEdit = function cancelCurrentEdit(){\n    return (activeEditController ? activeEditController.cancelCurrentEdit() : true);\n  };\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/slick.core.js\n **/","// todo: convert and export the other plugins here\nexport CellSelectionModel from './slick.cellselectionmodel.js';\n\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/index.js\n **/","import Slick from '../src/slick.core';\n\nSlick.CellSelectionModel = CellSelectionModel;\nexport default CellSelectionModel;\n\nfunction CellSelectionModel(options = {\n    selectActiveCell: true\n  }){\n  var _grid;\n  var _canvas;\n  var _ranges = [];\n  var _self = this;\n  var _selector = new Slick.CellRangeSelector({\n    selectionCss: {\n      border: \"2px solid black\"\n    }\n  });\n  var _options;\n  var _defaults = {\n    selectActiveCell: true\n  };\n\n  function init(grid){\n    _options = Object.assign({}, options);\n    _grid = grid;\n    _canvas = _grid.getCanvasNode();\n    _grid.onActiveCellChanged.subscribe(handleActiveCellChange);\n    _grid.onKeyDown.subscribe(handleKeyDown);\n    grid.registerPlugin(_selector);\n    _selector.onCellRangeSelected.subscribe(handleCellRangeSelected);\n    _selector.onBeforeCellRangeSelected.subscribe(handleBeforeCellRangeSelected);\n  }\n\n  function destroy(){\n    _grid.onActiveCellChanged.unsubscribe(handleActiveCellChange);\n    _grid.onKeyDown.unsubscribe(handleKeyDown);\n    _selector.onCellRangeSelected.unsubscribe(handleCellRangeSelected);\n    _selector.onBeforeCellRangeSelected.unsubscribe(handleBeforeCellRangeSelected);\n    _grid.unregisterPlugin(_selector);\n  }\n\n  function removeInvalidRanges(ranges){\n    var result = [];\n\n    for (var i = 0; i < ranges.length; i++){\n      var r = ranges[i];\n      if (_grid.canCellBeSelected(r.fromRow, r.fromCell) && _grid.canCellBeSelected(r.toRow, r.toCell)){\n        result.push(r);\n      }\n    }\n\n    return result;\n  }\n\n  function setSelectedRanges(ranges){\n    // simle check for: empty selection didn't change, prevent firing onSelectedRangesChanged\n    if ((!_ranges || _ranges.length === 0) && (!ranges || ranges.length === 0)){\n      return;\n    }\n\n    _ranges = removeInvalidRanges(ranges);\n    _self.onSelectedRangesChanged.notify(_ranges);\n  }\n\n  function getSelectedRanges(){\n    return _ranges;\n  }\n\n  function handleBeforeCellRangeSelected(e, args){\n    if (_grid.getEditorLock().isActive()){\n      e.stopPropagation();\n      return false;\n    }\n  }\n\n  function handleCellRangeSelected(e, args){\n    setSelectedRanges([args.range]);\n  }\n\n  function handleActiveCellChange(e, args){\n    if (_options.selectActiveCell && args.row != null && args.cell != null){\n      setSelectedRanges([new Slick.Range(args.row, args.cell)]);\n    }\n  }\n\n  function handleKeyDown(e){\n    /***\n     * Кey codes\n     * 37 left\n     * 38 up\n     * 39 right\n     * 40 down\n     */\n    var ranges, last;\n    var active = _grid.getActiveCell();\n\n    if (active && e.shiftKey && !e.ctrlKey && !e.altKey &&\n      (e.which == 37 || e.which == 39 || e.which == 38 || e.which == 40)){\n\n      ranges = getSelectedRanges();\n      if (!ranges.length)\n        ranges.push(new Slick.Range(active.row, active.cell));\n\n      // keyboard can work with last range only\n      last = ranges.pop();\n\n      // can't handle selection out of active cell\n      if (!last.contains(active.row, active.cell))\n        last = new Slick.Range(active.row, active.cell);\n\n      var dRow = last.toRow - last.fromRow,\n        dCell = last.toCell - last.fromCell,\n        // walking direction\n        dirRow = active.row == last.fromRow ? 1 : -1,\n        dirCell = active.cell == last.fromCell ? 1 : -1;\n\n      if (e.which == 37){\n        dCell -= dirCell;\n      } else if (e.which == 39){\n        dCell += dirCell;\n      } else if (e.which == 38){\n        dRow -= dirRow;\n      } else if (e.which == 40){\n        dRow += dirRow;\n      }\n\n      // define new selection range\n      var new_last = new Slick.Range(active.row, active.cell, active.row + dirRow * dRow, active.cell + dirCell * dCell);\n      if (removeInvalidRanges([new_last]).length){\n        ranges.push(new_last);\n        var viewRow = dirRow > 0 ? new_last.toRow : new_last.fromRow;\n        var viewCell = dirCell > 0 ? new_last.toCell : new_last.fromCell;\n        _grid.scrollRowIntoView(viewRow);\n        _grid.scrollCellIntoView(viewRow, viewCell);\n      }\n      else\n        ranges.push(last);\n\n      setSelectedRanges(ranges);\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  Object.extend(this, {\n    \"getSelectedRanges\": getSelectedRanges,\n    \"setSelectedRanges\": setSelectedRanges,\n\n    \"init\": init,\n    \"destroy\": destroy,\n\n    \"onSelectedRangesChanged\": new Slick.Event()\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./plugins/slick.cellselectionmodel.js\n **/"],"sourceRoot":""}